# VE482 — Introduction to Operating Systems Homework 7

[TOC]

## Ex. 1 — Page replacement algorithm

**1. Explain the content of the new table entries if a clock interrupt occurs at tick 10.**

| Page | Time stamp | Present | Referenced | Modified |
| ---- | ---------- | ------- | ---------- | -------- |
| 0    | 6          | 1       | 0          | 1        |
| 1    | 9          | 1       | **0**      | 0        |
| 2    | 9          | 1       | **0**      | 1        |
| 3    | 7          | 1       | 0          | 0        |
| 4    | 4          | 0       | 0          | 0        |

​	At tick 10, due to the clock interrupt all the **R** bits are set to 0.



**2. Due to a read request to page 4 a page fault occurs at tick 10. Describe the new table entry.**

Suppose the hand pointer originally points to Page 0. According to the WSClock page replacement algotithm, it will schedule a write process for page 0 and move forward. Suppose the hand pointer changes R bit of page 1 & 2 to 0 and points to page 3 before the write process of page 1 finishes, page 3 will be replaced.

|      | Time stamp | Present | Referenced | Modified          |
| ---- | ---------- | ------- | ---------- | ----------------- |
| 0    | 6          | 1       | 0          | 1 (been writting) |
| 1    | 9          | 1       | 0          | 0                 |
| 2    | 9          | 1       | 0          | 1                 |
| 3    | 10         | 1       | 0          | 0                 |
| 4    | 4          | 0       | 0          | 0                 |



## Ex. 2 — Minix 3

**1a)  the constants with number and name for the system calls?**

`/include/minix/callnr.h`

```c
#define NCALLS		 112	/* number of system calls allowed */

#define EXIT		   1 
#define FORK		   2 
#define READ		   3 
#define WRITE		   4 
#define OPEN		   5 
#define CLOSE		   6 
#define WAIT		   7
#define CREAT		   8 
#define LINK		   9 
#define UNLINK		 10
...
```



**1b) the names of the system call routines?**

`/servers/*/table.c`



**1c) the prototypes of the system call routines?**

`/servers/*/proto.h`



**1d) the system calls of type “signal” coded?**

`/servers/pm/signal.c`

```c
/* This file handles signals, which are asynchronous events and are generally
 * a messy and unpleasant business.  Signals can be generated by the KILL
 * system call, or from the keyboard (SIGINT) or from the clock (SIGALRM).
 * In all cases control eventually passes to check_sig() to see which processes
 * can be signaled.  The actual signaling is done by sig_proc().
 *
 * The entry points into this file are:
 *   do_sigaction:	perform the SIGACTION system call
 *   do_sigpending:	perform the SIGPENDING system call
 *   do_sigprocmask:	perform the SIGPROCMASK system call
 *   do_sigreturn:	perform the SIGRETURN system call
 *   do_sigsuspend:	perform the SIGSUSPEND system call
 *   do_kill:		perform the KILL system call
 *   do_pause:		perform the PAUSE system call
 *   process_ksig:	process a signal an behalf of the kernel
 *   sig_proc:		interrupt or terminate a signaled process
 *   check_sig:		check which processes to signal with sig_proc()
 *   check_pending:	check if a pending signal can now be delivered
 *   restart_sigs: 	restart signal work after finishing a FS call
 */

FORWARD _PROTOTYPE( void unpause, (struct mproc *rmp)			);
FORWARD _PROTOTYPE( int sig_send, (struct mproc *rmp, int signo)	);
FORWARD _PROTOTYPE( void sig_proc_exit, (struct mproc *rmp, int signo)	);

...
```





2. **What problems arise when trying to implement a system call `int getchpids(int n, pid_t *childpid) `which “writes” the pids of up to n children of the current process into `*childpid`?**

   since `getchpids` is called from user space, there may exist some memory accessing issues 

   

3. **Write a “sub-system call” `int getnchpid(int n, pid_t childpid)` which retrieves the n-th child process.**

   ```c
   #include <unistd.h>
   #include "mproc.h"
   
   #define OK 0
   
   int getnchpid(int n, pid_t *childpid){
     register struct mproc *rmc; 
     if (childpid == NULL) return -1;
     if (n > NR_PROCS) return -1;
     rmc = &mproc[n];
     if (rmc->mp_parent != who_p) return -1;
     *childpid = rmc->mp_pid;
   
     return OK;
   
   }
   ```

   

4. **Using the previous sub-system call, implement the original getchpids system call. The returned int value corresponds to the number of pids in *childpid, or -1 on an error.**

   ```c
   #include <unistd.h>
   #include "mproc.h"
   
   #define OK 0
   
   int getchpids(int n, pid_t *childpid){
     int index;
     for (index = 0; index < n; index++){
       if (getnchpid(index, childpid+index) != OK){
         index = -1;
         break;
       }
     }
   
     return index;
   }
   ```

   

5. **Write a short program that demonstrate the previous system calls.**

   ```c
   #include <unistd.h>
   #include <stdio.h>
   #include <assert.h>
   
   int main(){
     pid_t childpid[10];
     int childNum = 0;
     pid_t childpidRef[10];
   
     while(childNum <= 5){
       pid_t pid = fork();
       if (pid == 0){
         childpidRef[childNum++] = pid;
       }
       else{
         exit (0);
       }
     }
     
     getchpid(childNum, childpid);
     
     for(int i=0;i<childNum;i++){
       assert(childpidRef[i] == childpid[i]);
     }
   
     return 0;
   }
   ```

   

6. **The above strategy solves the initial problem through the introduction of a sub-system call.**
  **a) What are the drawbacks and benefits of this solution?**

  Drawbacks: performance is bad since it requires several calls of the sub-system call

  Benefits: safe, and easy to implement

  **b) Can you think of any alternative approach? If yes, provide basic details, without any imple- mentation.**

  we can simply pass the whole array and let the sub-system call handle the whole job.



## Ex. 3 — Research on ext2 filesystem

​	The Second Extended File system was devised (by Rémy Card) as an extensible and powerful file system for Linux. It is also the most successful file system so far in the Linux community and is the basis for all of the currently shipping Linux distributions.

​	The EXT2 file system, like a lot of the file systems, is built on the premise that the data held in files is kept in data blocks. These data blocks are all of the same length and, although that length can vary between different EXT2 file systems the block size of a particular EXT2 file system is set when it is created (using *mke2fs* ). Every file's size is rounded up to an integral number of blocks. If the block size is 1024 bytes, then a file of 1025 bytes will occupy two 1024 byte blocks. Unfortunately this means that on average you waste half a block per file. Usually in computing you trade off CPU usage for memory and disk space utilisation. In this case Linux, along with most operating systems, trades off a relatively inefficient disk usage in order to reduce the workload on the CPU. Not all of the blocks in the file system hold data, some must be used to contain the information that describes the structure of the file system. EXT2 defines the file system topology by describing each file in the system with an inode data structure. An inode describes which blocks the data within a file occupies as well as the access rights of the file, the file's modification times and the type of the file. Every file in the EXT2 file system is described by a single inode and each inode has a single unique number identifying it. The inodes for the file system are all kept together in inode tables. EXT2 directories are simply special files (themselves described by inodes) which contain pointers to the inodes of their directory entries.

![figure8116](http://www.science.unitn.it/~fiorella/guidelinux/tlk/img82.gif)

​	The figure shows the layout of the EXT2 file system as occupying a series of blocks in a block structured device. So far as each file system is concerned, block devices are just a series of blocks which can be read and written. A file system does not need to concern itself with where on the physical media a block should be put, that is the job of the device's driver. Whenever a file system needs to read information or data from the block device containing it, it requests that its supporting device driver reads an integral number of blocks. The EXT2 file system divides the logical partition that it occupies into Block Groups.  Each group duplicates information critical to the integrity of the file system as well as holding real files and directories as blocks of information and data. This duplication is neccessary should a disaster occur and the file system need recovering. The subsections describe in more detail the contents of each Block Group.



## Reference 

[1] http://www.science.unitn.it/~fiorella/guidelinux/tlk/node95.html







